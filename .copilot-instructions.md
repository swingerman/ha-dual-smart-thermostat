# Copilot Instructions for Home Assistant Dual Smart Thermostat

## Project Overview

The `dual_smart_thermostat` is an enhanced version of the generic thermostat implemented in Home Assistant. It provides sophisticated thermostat logic with multiple HVAC modes, device types, and advanced features like floor temperature control, opening detection, and preset management.

## Architecture

The project follows a modular architecture designed for safety, maintainability, and feature isolation:

### Core Directory Structure

```
custom_components/dual_smart_thermostat/
├── __init__.py              # Component initialization
├── climate.py               # Main climate entity implementation
├── config_flow.py           # Configuration flow
├── const.py                 # Constants and configurations
├── services.yaml            # Service definitions
├── hvac_device/             # Device type implementations
├── managers/                # Shared logic managers
├── hvac_controller/         # Control logic
├── hvac_action_reason/      # Action reason tracking
├── preset_env/              # Preset environment handling
└── translations/            # Localization files
```

### Key Components

#### 1. HVAC Devices (`./hvac_device/`)
Device-specific implementations for different HVAC equipment types:
- `heater_device.py` - Standard heating devices
- `cooler_device.py` - Cooling/AC devices  
- `heat_pump_device.py` - Heat pump systems
- `cooler_fan_device.py` - Fan-enabled cooling
- `heater_aux_heater_device.py` - Two-stage heating
- `heater_cooler_device.py` - Dual heating/cooling
- `generic_hvac_device.py` - Base device class
- `hvac_device_factory.py` - Device creation factory

#### 2. Managers (`./managers/`)
Shared logic components that handle specific aspects of thermostat operation:
- `environment_manager.py` - Environmental conditions tracking
- `feature_manager.py` - Feature enablement and configuration
- `hvac_power_manager.py` - Power management and cycling
- `opening_manager.py` - Window/door opening detection
- `preset_manager.py` - Preset mode handling
- `state_manager.py` - State persistence and restoration

#### 3. Controllers (`./hvac_controller/`)
Control logic for different HVAC operation modes:
- `generic_controller.py` - Base controller class
- `heater_controller.py` - Heating control logic
- `cooler_controller.py` - Cooling control logic
- `hvac_controller.py` - Main controller coordination

#### 4. Action Reasons (`./hvac_action_reason/`)
System for tracking why HVAC actions occur:
- `hvac_action_reason.py` - Base action reason handling
- `hvac_action_reason_internal.py` - Internal system reasons
- `hvac_action_reason_external.py` - External trigger reasons

## Development Guidelines

### Code Organization Principles

1. **Separation of Concerns**: Each component has a single, well-defined responsibility
2. **Device Abstraction**: Different HVAC equipment types are abstracted into separate device classes
3. **Manager Pattern**: Shared logic is extracted into manager classes to avoid duplication
4. **Controller Pattern**: Control logic is separated from device logic for flexibility

### Basic Development Setup

**Python Environment**: Requires Python 3.12+ (project targets Python 3.13)

**Code Validation**: 
```bash
# Basic syntax check
python -m py_compile custom_components/dual_smart_thermostat/climate.py

# Run pre-commit hooks (requires installation)
pre-commit run --all-files

# Format code with black
black custom_components/

# Sort imports with isort  
isort custom_components/
```

**VSCode Setup**: 
- Configured to use black formatter automatically on save
- Pytest testing enabled
- Python analysis and auto-imports configured

### Feature Development Workflow

1. **Analysis**: Determine which components need modification
   - Device types: Add new device classes if needed
   - Shared logic: Use or extend existing managers
   - Control logic: Modify appropriate controllers

2. **Implementation**: Follow existing patterns
   - Inherit from base classes where appropriate
   - Use dependency injection for managers
   - Maintain consistent error handling

3. **Testing**: All new features must be covered with tests
   - Unit tests for individual components
   - Integration tests for feature workflows
   - Edge case testing for error conditions

### Testing Requirements

**Location**: All tests are in `./tests/`

**Coverage Requirements**: 
- Every new feature MUST be covered with tests
- Tests should cover both success and failure scenarios
- Test files follow naming convention: `test_<feature_name>.py`

**Test Structure Examples**:
```python
# Unit test for device functionality
def test_heater_device_turn_on():
    # Test device-specific behavior

# Integration test for feature workflow  
def test_two_stage_heating_activation():
    # Test complete feature from trigger to completion

# Edge case testing
def test_sensor_unavailable_handling():
    # Test error conditions and recovery
```

**Existing Test Files**:
- `test_cooler_mode.py` - Cooling mode functionality
- `test_heater_mode.py` - Heating mode functionality  
- `test_heat_pump_mode.py` - Heat pump operations
- `test_dual_mode.py` - Dual heating/cooling mode
- `test_fan_mode.py` - Fan-only operations
- `test_dry_mode.py` - Humidity/dry mode

### Code Style and Quality

**Formatting**: Project uses automated formatting tools:
- `black` - Code formatting (configured in VSCode as default formatter)
- `isort` - Import sorting  
- `flake8` - Linting
- `codespell` - Spell checking
- `mypy` - Type checking

**Pre-commit Hooks**: All changes go through quality checks
- Pre-commit hooks automatically run on commit
- Run `pre-commit run --all-files` to check all files manually

**Type Hints**: Use type hints for all new code:
```python
from typing import Optional, Dict, List
from homeassistant.core import HomeAssistant

def setup_device(hass: HomeAssistant, config: Dict[str, Any]) -> Optional[HVACDevice]:
    """Setup HVAC device with proper typing."""
```

## Key Features and Concepts

### HVAC Modes Supported
- **Heat Only**: Single heating device
- **Cool Only**: Single cooling device  
- **Heat/Cool**: Dual heating and cooling
- **Heat Pump**: Single device for both heating/cooling
- **Fan Only**: Fan operation without heating/cooling
- **Two-Stage Heating**: Primary + auxiliary/secondary heater
- **Dry Mode**: Humidity control

### Advanced Features
- **Floor Temperature Control**: Min/max floor temperature limits
- **Opening Detection**: Window/door sensors that pause HVAC
- **Preset Modes**: Pre-configured temperature/humidity settings
- **HVAC Action Reasons**: Tracking why actions occur (internal vs external)
- **Tolerance Controls**: Fine-tuned temperature control
- **Keep-Alive**: Periodic device communication
- **Sensor Stale Detection**: Handling of failed sensors

### Configuration Patterns

**Device Configuration**:
```yaml
climate:
  - platform: dual_smart_thermostat
    name: Study
    heater: switch.study_heater          # Required: heating device
    cooler: switch.study_cooler          # Optional: cooling device
    target_sensor: sensor.study_temp     # Required: temperature sensor
```

**Advanced Features**:
```yaml
    # Two-stage heating
    secondary_heater: switch.aux_heater
    secondary_heater_timeout: 00:05:00
    
    # Floor protection
    floor_sensor: sensor.floor_temp
    max_floor_temp: 28
    min_floor_temp: 5
    
    # Opening detection
    openings:
      - binary_sensor.window1
      - entity_id: binary_sensor.window2
        timeout: 00:00:30
```

## Working with Different Components

### Adding New Device Types

1. Create new device class in `hvac_device/`
2. Inherit from `GenericHVACDevice` or appropriate base class
3. Implement required methods: `turn_on()`, `turn_off()`, `is_on()`
4. Add device creation logic to `hvac_device_factory.py`
5. Add comprehensive tests

### Extending Managers

1. Identify which manager handles related functionality
2. Add new methods following existing patterns
3. Maintain backward compatibility
4. Update relevant controller to use new functionality
5. Add tests for new manager methods

### Modifying Controllers

1. Controllers orchestrate between devices and managers
2. Follow existing error handling patterns
3. Maintain separation between control logic and device operations
4. Add logging for debugging
5. Test all control flow paths

## Common Development Patterns

### Error Handling
```python
try:
    await device.turn_on()
except Exception as err:
    _LOGGER.error("Failed to turn on device: %s", err)
    # Graceful degradation
```

### State Management
```python
# Use state manager for persistence
self._state_manager.set_hvac_mode(mode)
self._state_manager.save_state()
```

### Device Interaction
```python
# Always check device availability
if self._heater_device.is_available():
    await self._heater_device.turn_on()
```

### Manager Coordination
```python
# Managers work together
if self._opening_manager.is_any_opening_open():
    if self._feature_manager.is_floor_protection_enabled():
        # Handle complex feature interactions
```

## Debugging and Logging

**Log Levels**:
- `DEBUG`: Detailed operation flow
- `INFO`: Important state changes  
- `WARNING`: Recoverable issues
- `ERROR`: Failed operations

**Log Categories**:
```python
_LOGGER = logging.getLogger(__name__)

# Device operations
_LOGGER.debug("Turning on heater device")

# State changes  
_LOGGER.info("HVAC mode changed to %s", new_mode)

# Error conditions
_LOGGER.error("Sensor %s is unavailable", sensor_id)
```

## Best Practices

1. **Minimal Changes**: Make the smallest possible changes to achieve goals
2. **Test First**: Write tests before implementing features when possible
3. **Follow Patterns**: Use existing architectural patterns and coding styles
4. **Document Intent**: Add docstrings for complex logic
5. **Handle Errors**: Always consider failure scenarios
6. **Backward Compatibility**: Don't break existing configurations
7. **Performance**: Consider Home Assistant's async nature

## Example Development Workflow

1. **Understand the Feature**: Read existing documentation and code
2. **Plan Components**: Identify which devices/managers/controllers need changes
3. **Write Tests**: Create failing tests for the new functionality
4. **Implement Changes**: Make minimal changes following existing patterns
5. **Run Tests**: Ensure all tests pass including existing ones
6. **Code Quality**: Run pre-commit hooks and fix any issues
7. **Documentation**: Update relevant documentation if needed

This modular architecture allows for safe development and testing of new features while maintaining the sophisticated thermostat logic that users depend on.