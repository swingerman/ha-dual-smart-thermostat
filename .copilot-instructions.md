# Copilot Instructions for Home Assistant Dual Smart Thermostat

## Project Overview

The `dual_smart_thermostat` is an enhanced version of the generic thermostat implemented in Home Assistant. It provides sophisticated thermostat logic with multiple HVAC modes, device types, and advanced features like floor temperature control, opening detection, and preset management.

## Architecture

The project follows a modular architecture designed for safety, maintainability, and feature isolation:

### Core Directory Structure

```
custom_components/dual_smart_thermostat/
├── __init__.py              # Component initialization
├── climate.py               # Main climate entity implementation
├── config_flow.py           # Configuration flow
├── const.py                 # Constants and configurations
├── services.yaml            # Service definitions
├── hvac_device/             # Device type implementations
├── managers/                # Shared logic managers
├── hvac_controller/         # Control logic
├── hvac_action_reason/      # Action reason tracking
├── preset_env/              # Preset environment handling
└── translations/            # Localization files
```

### Key Components

#### 1. HVAC Devices (`./hvac_device/`)
Device-specific implementations for different HVAC equipment types:
- `heater_device.py` - Standard heating devices
- `cooler_device.py` - Cooling/AC devices
- `heat_pump_device.py` - Heat pump systems
- `cooler_fan_device.py` - Fan-enabled cooling
- `heater_aux_heater_device.py` - Two-stage heating
- `heater_cooler_device.py` - Dual heating/cooling
- `generic_hvac_device.py` - Base device class
- `hvac_device_factory.py` - Device creation factory

#### 2. Managers (`./managers/`)
Shared logic components that handle specific aspects of thermostat operation:
- `environment_manager.py` - Environmental conditions tracking
- `feature_manager.py` - Feature enablement and configuration
- `hvac_power_manager.py` - Power management and cycling
- `opening_manager.py` - Window/door opening detection
- `preset_manager.py` - Preset mode handling
- `state_manager.py` - State persistence and restoration

#### 3. Controllers (`./hvac_controller/`)
Control logic for different HVAC operation modes:
- `generic_controller.py` - Base controller class
- `heater_controller.py` - Heating control logic
- `cooler_controller.py` - Cooling control logic
- `hvac_controller.py` - Main controller coordination

#### 4. Action Reasons (`./hvac_action_reason/`)
System for tracking why HVAC actions occur:
- `hvac_action_reason.py` - Base action reason handling
- `hvac_action_reason_internal.py` - Internal system reasons
- `hvac_action_reason_external.py` - External trigger reasons

## Development Guidelines

### Code Organization Principles

1. **Separation of Concerns**: Each component has a single, well-defined responsibility
2. **Device Abstraction**: Different HVAC equipment types are abstracted into separate device classes
3. **Manager Pattern**: Shared logic is extracted into manager classes to avoid duplication
4. **Controller Pattern**: Control logic is separated from device logic for flexibility

### Configuration Dependency Requirements

**CRITICAL: When adding new features or configuration parameters, you MUST update configuration dependencies:**

1. **New Configuration Parameters**: Any new parameter added to `const.py` or config flow MUST be analyzed for dependencies
2. **Conditional Parameters**: Parameters that only make sense when other parameters are configured MUST be documented in dependency files
3. **Required Updates**: All new features with conditional parameters require updating:
   - `tools/focused_config_dependencies.json` - Add new conditional dependencies
   - `tools/config_validator.py` - Update validation rules
   - `docs/config/CRITICAL_CONFIG_DEPENDENCIES.md` - Document new dependencies with examples

**Configuration Dependency Update Checklist:**
- [ ] Identify if new parameter depends on another parameter to function
- [ ] Add conditional dependency to `tools/focused_config_dependencies.json`
- [ ] Update validation rules in `tools/config_validator.py`
- [ ] Add documentation with examples to `docs/config/CRITICAL_CONFIG_DEPENDENCIES.md`
- [ ] Test validation with example configurations
- [ ] Verify config flow properly handles new dependencies

**Examples of Conditional Dependencies:**
- Parameters requiring enabling parameters: `max_floor_temp` requires `floor_sensor`
- Feature-specific parameters: `fan_mode` requires `fan` entity
- Mode-specific parameters: `target_temp_low` requires `heat_cool_mode: true`

**Validation Testing Required:**
```bash
# Test new dependencies
python tools/config_validator.py
```

### Configuration Flow Integration Requirements

**CRITICAL**: Every added or modified configuration option MUST be integrated into the appropriate configuration flows (config, reconfigure, or options flows). This is a mandatory requirement for all configuration changes.

#### When Flow Integration is Required

Flow integration is required whenever you:
1. Add a new configuration parameter to `const.py` or `schemas.py`
2. Modify an existing configuration parameter's behavior or validation
3. Add a new feature that requires user configuration
4. Change how configuration options interact with each other

#### Which Flow(s) to Update

Determine which flow(s) need updates based on the type of change:

1. **Initial Configuration Flow** (`config_flow.py`):
   - New system types or HVAC modes
   - New required entities (heater, cooler, sensors)
   - New features that should be configured during initial setup
   - Core system behavior changes

2. **Reconfigure Flow** (`config_flow.py` - reconfigure handlers):
   - Changes to existing system configuration that require reconfiguration
   - System type switching
   - Entity replacement or updates
   - Any change that affects the initial configuration flow

3. **Options Flow** (`options_flow.py`):
   - Feature toggles (enabling/disabling features)
   - Feature-specific settings (thresholds, timeouts, behaviors)
   - Preset configurations
   - Advanced settings that don't require reconfiguration
   - Any setting that users might want to change after initial setup

**Rule of Thumb**: If users need to configure it during initial setup, add it to config/reconfigure flows. If users might want to adjust it later, add it to options flow. Often, you'll need to add to both.

#### Flow Integration Process

1. **Add Constants and Schema**: Define configuration keys in `const.py` and validation schemas in `schemas.py`
2. **Add Configuration Step**: Create or update step handlers in `feature_steps/` or flow files
3. **Update Flow Navigation**: Modify `_determine_next_step()` or flow handler logic to include new step
4. **Add Data Validation**: Implement validation logic with clear error messages
5. **Update Translations**: Add user-facing text to `translations/en.json`
6. **Add Tests**: Create unit and integration tests in `tests/config_flow/`

#### Testing Requirements for Flow Changes

**REQUIRED**: All flow changes must include:
- Unit tests for step handler logic and validation
- Integration tests for complete flow with new option
- Persistence tests (config → options flow)
- Edge case testing
- Manual testing across different system types

#### Clarification Process

If it's unclear how to integrate a configuration change into the flows:

1. **Analyze the Feature**: Determine what it controls, whether it's core or optional, and its dependencies
2. **Review Similar Features**: Find and follow patterns from similar existing features
3. **Check Dependencies**: Identify where it should appear in step ordering
4. **Ask for Clarification**: Document your analysis and ask specifically which flow(s) to update

**Remember**: When in doubt, add to both config/reconfigure AND options flows to provide maximum flexibility.

For detailed examples and step-by-step guidance, see the "Configuration Flow Integration" section in `CLAUDE.md`.

### Configuration Flow Step Ordering Rules

**CRITICAL: Configuration flow step ordering must follow these rules:**

1. **Openings Steps Must Be Last Configuration Steps**: The openings configuration steps (`openings_toggle`, `openings_selection`, `openings_config`) MUST always be among the last configuration steps because their content depends on previously configured features (system type, heating/cooling entities, etc.).

2. **Presets Steps Must Be Final Steps**: The presets configuration steps (`preset_selection`, `presets`) MUST always be the absolute final configuration steps because:
   - Preset configuration depends on all other system settings
   - Preset temperature ranges depend on configured sensors and system capabilities
   - Preset behavior varies based on system type and features

3. **Features Configuration Step Ordering**: When adding or modifying feature configuration steps, ensure they are ordered logically:
   - System type and basic entity configuration first
   - Core feature toggles (floor heating, fan, humidity)
   - Feature-specific configuration steps
   - Openings configuration (depends on system type and entities)
   - Preset configuration (depends on all previous steps)

**Detailed Documentation**: See `docs/config_flow/step_ordering.md` for comprehensive rules and examples.

**Implementation Requirements:**
- The `_determine_next_step()` method in `config_flow.py` MUST respect this ordering
- The `OptionsFlowHandler` in `options_flow.py` MUST follow the same ordering rules
- Any new configuration steps MUST be inserted in the correct position based on their dependencies
- Test configuration flows to ensure step ordering is correct
- Add tests to verify that openings and presets steps are always positioned correctly in the flow

**Testing Requirements:**
- Test that openings configuration steps come after core feature configuration
- Test that preset configuration steps are always the final steps
- Test the complete flow for different system types to verify step ordering
- Add integration tests that verify the dependency-based ordering

**Example Correct Flow Order:**
1. System type selection
2. Basic entity configuration (heater, cooler, sensor)
3. System-specific configuration (heat pump, dual stage, etc.)
4. Feature toggles (floor heating, fan, humidity)
5. Feature-specific configuration
6. **Openings configuration** (among last steps)
7. **Presets configuration** (final steps)

### When to Update Documentation

**Matrix Updates Required:**
- Adding new HVAC modes (HVACMode.NEW_MODE)
- Creating new device types in `hvac_device/`
- Implementing new feature managers in `managers/`
- Adding comprehensive test coverage for existing features
- Fixing or updating existing tests

**Documentation Maintenance Checklist:**
- [ ] Update README.md feature matrix for user-visible changes
- [ ] Update tests/FEATURES.md for test coverage changes
- [ ] Ensure feature names match implementation
- [ ] Verify documentation links are valid
- [ ] Update test status indicators accurately

### Feature and Test Coverage Matrix Maintenance

**Key Documentation Files:**
- `README.md` - Main feature matrix (lines 17-33) for user-facing documentation
- `tests/FEATURES.md` - Detailed test coverage matrix for development tracking

### When to Update the Feature Matrix

**README.md Feature Matrix:**
1. **Adding New Features**: When implementing a new HVAC mode, device type, or major capability
2. **Feature Changes**: When modifying existing feature behavior or capabilities
3. **Documentation Updates**: When adding new documentation sections or reorganizing docs

**tests/FEATURES.md Test Coverage Matrix:**
1. **Adding Tests**: When creating new test files or adding significant test coverage
2. **Test Status Changes**: When fixing broken tests (! → X) or identifying missing tests (? → !)
3. **New HVAC Modes**: When adding support for new HVAC modes (add new column)
4. **Feature Implementation**: When implementing previously untested features

### How to Update the Matrices

**Feature Matrix in README.md:**
- Add new features as table rows with icon, description, and documentation link
- Keep feature names consistent with actual implementation
- Ensure documentation links point to valid sections
- Use clear, user-friendly feature names

**Test Coverage Matrix in tests/FEATURES.md:**
- Use legend: `X` = Test exists and passes, `!` = Needs attention, `?` = Missing/Unknown, `N/A` = Not applicable
- Add new HVAC modes as columns when supported modes expand
- Update test status when adding or fixing tests
- Include test file summary with test counts

### Automated Checks for Matrix Maintenance

When reviewing code changes, verify:
1. New device types in `hvac_device/` are reflected in feature matrix
2. New HVAC modes in device files are added to test matrix columns
3. New test files are included in test coverage tracking
4. Feature additions include corresponding documentation updates

### Matrix Update Examples

**Adding a new HVAC mode:**
```diff
# In README.md
| **New Mode Name** | ![icon](path) | [docs](#new-mode) |

# In tests/FEATURES.md
| Feature | Fan Mode | Cool Mode | Heat Mode | Heat Cool Mode | Dry Mode | Heat Pump Mode | New Mode |
```

**Updating test status:**
```diff
# When fixing a test
- | sensor bad value | X | X | ! | ! | X | X |
+ | sensor bad value | X | X | X | ! | X | X |
```

**Adding new feature:**
```diff
# In README.md - add after existing features
| **New Feature Name** | ![icon](docs/images/icon.png) | [docs](#new-feature) |

# In tests/FEATURES.md - add as new row
| new feature test | X | X | ? | ! | N/A | X |
```

### Basic Development Setup

**Python Environment**: Requires Python 3.12+ (project targets Python 3.13)

**Development Dependencies**: Install linting tools and development dependencies:
```bash
pip install -r requirements-dev.txt
```

**Code Validation**:
```bash
# Basic syntax check
python -m py_compile custom_components/dual_smart_thermostat/climate.py

# Run all linting tools (REQUIRED before committing)
isort . --recursive --diff    # Check import sorting
black --check .               # Check code formatting
flake8 .                      # Check code style/linting
codespell                     # Check spelling

# Fix linting issues automatically
isort .                       # Fix import sorting
black .                       # Fix code formatting

# Run pre-commit hooks (includes all linting tools)
pre-commit run --all-files
```

**VSCode Setup**:
- Configured to use black formatter automatically on save
- Pytest testing enabled
- Python analysis and auto-imports configured

### Feature Development Workflow

1. **Analysis**: Determine which components need modification
   - Device types: Add new device classes if needed
   - Shared logic: Use or extend existing managers
   - Control logic: Modify appropriate controllers

2. **Implementation**: Follow existing patterns
   - Inherit from base classes where appropriate
   - Use dependency injection for managers
   - Maintain consistent error handling

3. **Configuration Flow Integration**: **CRITICAL** - Integrate configuration changes into flows
   - Determine which flow(s) need updates (config, reconfigure, options)
   - Add configuration steps and update flow navigation
   - Add data validation and error handling
   - Update translations for user-facing text
   - See "Configuration Flow Integration Requirements" section above for detailed guidance

4. **Configuration Dependencies**: Update dependency tracking for new parameters
   - Check if new parameter requires another parameter to function
   - Update `tools/focused_config_dependencies.json` with new conditional dependencies
   - Add validation rules to `tools/config_validator.py`
   - Document with examples in `docs/config/CRITICAL_CONFIG_DEPENDENCIES.md`
   - Test validation: `python tools/config_validator.py`

5. **Testing**: All new features must be covered with tests
   - Unit tests for individual components
   - Integration tests for feature workflows
   - **Config flow tests** for configuration integration
   - Edge case testing for error conditions

### Testing Requirements

**Location**: All tests are in `./tests/`

**Coverage Requirements**:
- Every new feature MUST be covered with tests
- Tests should cover both success and failure scenarios
- Test files follow naming convention: `test_<feature_name>.py`

**Test Structure Examples**:
```python
# Unit test for device functionality
def test_heater_device_turn_on():
    # Test device-specific behavior

# Integration test for feature workflow
def test_two_stage_heating_activation():
    # Test complete feature from trigger to completion

# Edge case testing
def test_sensor_unavailable_handling():
    # Test error conditions and recovery
```

**Existing Test Files**:
- `test_cooler_mode.py` - Cooling mode functionality
- `test_heater_mode.py` - Heating mode functionality
- `test_heat_pump_mode.py` - Heat pump operations
- `test_dual_mode.py` - Dual heating/cooling mode
- `test_fan_mode.py` - Fan-only operations
- `test_dry_mode.py` - Humidity/dry mode

### Code Style and Quality

**Mandatory Linting Requirements**: All code changes MUST pass the following linting tools before being committed:

1. **isort** - Import sorting and organization
   - Configuration: `setup.cfg` [isort] section
   - Requirements: Multi-line imports, trailing commas, proper grouping
   - Run locally: `isort . --recursive --diff` (check) or `isort .` (fix)

2. **black** - Code formatting
   - Configuration: Line length 88 characters, Python 3.13 compatible
   - Requirements: Consistent formatting, proper spacing, quote style
   - Run locally: `black --check .` (check) or `black .` (fix)

3. **flake8** - Code linting and style checking
   - Configuration: `setup.cfg` [flake8] section with specific ignores
   - Requirements: No unused imports, proper variable naming, line length compliance
   - Run locally: `flake8 .`

4. **codespell** - Spell checking in code and comments
   - Configuration: `setup.cfg` [codespell] section
   - Requirements: No misspellings in code, comments, or docstrings
   - Run locally: `codespell`

5. **mypy** - Type checking (optional but recommended)
   - Configuration: `setup.cfg` [mypy] section
   - Requirements: Proper type hints for new code
   - Run locally: `mypy .`

**Common Linting Fixes**:
```bash
# Fix import ordering issues
isort .

# Fix code formatting issues
black .

# Check for remaining issues
flake8 .
codespell
```

**Pre-commit Hooks**: All changes go through quality checks
- Pre-commit hooks automatically run on commit and will prevent commits that fail linting
- Run `pre-commit run --all-files` to check all files manually
- Install pre-commit: `pre-commit install`

**Type Hints**: Use type hints for all new code:
```python
from typing import Optional, Dict, List
from homeassistant.core import HomeAssistant

def setup_device(hass: HomeAssistant, config: Dict[str, Any]) -> Optional[HVACDevice]:
    """Setup HVAC device with proper typing."""
```

## Key Features and Concepts

### HVAC Modes Supported
- **Heat Only**: Single heating device
- **Cool Only**: Single cooling device
- **Heat/Cool**: Dual heating and cooling
- **Heat Pump**: Single device for both heating/cooling
- **Fan Only**: Fan operation without heating/cooling
- **Two-Stage Heating**: Primary + auxiliary/secondary heater
- **Dry Mode**: Humidity control

### Advanced Features
- **Floor Temperature Control**: Min/max floor temperature limits
- **Opening Detection**: Window/door sensors that pause HVAC
- **Preset Modes**: Pre-configured temperature/humidity settings
- **HVAC Action Reasons**: Tracking why actions occur (internal vs external)
- **Tolerance Controls**: Fine-tuned temperature control
- **Keep-Alive**: Periodic device communication
- **Sensor Stale Detection**: Handling of failed sensors

### Configuration Patterns

**Device Configuration**:
```yaml
climate:
  - platform: dual_smart_thermostat
    name: Study
    heater: switch.study_heater          # Required: heating device
    cooler: switch.study_cooler          # Optional: cooling device
    target_sensor: sensor.study_temp     # Required: temperature sensor
```

**Advanced Features**:
```yaml
    # Two-stage heating
    secondary_heater: switch.aux_heater
    secondary_heater_timeout: 00:05:00

    # Floor protection
    floor_sensor: sensor.floor_temp
    max_floor_temp: 28
    min_floor_temp: 5

    # Opening detection
    openings:
      - binary_sensor.window1
      - entity_id: binary_sensor.window2
        timeout: 00:00:30
```

## Working with Different Components

### Adding New Device Types

1. Create new device class in `hvac_device/`
2. Inherit from `GenericHVACDevice` or appropriate base class
3. Implement required methods: `turn_on()`, `turn_off()`, `is_on()`
4. Add device creation logic to `hvac_device_factory.py`
5. Add comprehensive tests

### Extending Managers

1. Identify which manager handles related functionality
2. Add new methods following existing patterns
3. Maintain backward compatibility
4. Update relevant controller to use new functionality
5. Add tests for new manager methods

### Modifying Controllers

1. Controllers orchestrate between devices and managers
2. Follow existing error handling patterns
3. Maintain separation between control logic and device operations
4. Add logging for debugging
5. Test all control flow paths

## Common Development Patterns

### Error Handling
```python
try:
    await device.turn_on()
except Exception as err:
    _LOGGER.error("Failed to turn on device: %s", err)
    # Graceful degradation
```

### State Management
```python
# Use state manager for persistence
self._state_manager.set_hvac_mode(mode)
self._state_manager.save_state()
```

### Device Interaction
```python
# Always check device availability
if self._heater_device.is_available():
    await self._heater_device.turn_on()
```

### Manager Coordination
```python
# Managers work together
if self._opening_manager.is_any_opening_open():
    if self._feature_manager.is_floor_protection_enabled():
        # Handle complex feature interactions
```

## Debugging and Logging

**Log Levels**:
- `DEBUG`: Detailed operation flow
- `INFO`: Important state changes
- `WARNING`: Recoverable issues
- `ERROR`: Failed operations

**Log Categories**:
```python
_LOGGER = logging.getLogger(__name__)

# Device operations
_LOGGER.debug("Turning on heater device")

# State changes
_LOGGER.info("HVAC mode changed to %s", new_mode)

# Error conditions
_LOGGER.error("Sensor %s is unavailable", sensor_id)
```

## Best Practices

1. **Minimal Changes**: Make the smallest possible changes to achieve goals
2. **Test First**: Write tests before implementing features when possible
3. **Follow Patterns**: Use existing architectural patterns and coding styles
4. **Document Intent**: Add docstrings for complex logic
5. **Handle Errors**: Always consider failure scenarios
6. **Backward Compatibility**: Don't break existing configurations
7. **Performance**: Consider Home Assistant's async nature

## Example Development Workflow

1. **Understand the Feature**: Read existing documentation and code
2. **Plan Components**: Identify which devices/managers/controllers need changes
3. **Write Tests**: Create failing tests for the new functionality
4. **Implement Changes**: Make minimal changes following existing patterns
5. **Integrate into Configuration Flows**: **CRITICAL** - For new or modified configuration options:
   ```bash
   # Determine which flow(s) need updates (config, reconfigure, options)
   # Add configuration steps in config_flow.py or options_flow.py
   # Update flow navigation logic (_determine_next_step())
   # Add data validation and error handling
   # Update translations/en.json with user-facing text
   # Add config flow tests in tests/config_flow/
   ```
6. **Update Configuration Dependencies**: For new parameters or features:
   ```bash
   # Check if new parameter requires another parameter to function
   # Update tools/focused_config_dependencies.json with new conditional dependencies
   # Add validation rules to tools/config_validator.py
   # Document with examples in docs/config/CRITICAL_CONFIG_DEPENDENCIES.md
   # Test validation
   python tools/config_validator.py
   ```
7. **Run Linting**: Ensure code passes all linting requirements:
   ```bash
   isort . --recursive --diff  # Check imports
   black --check .             # Check formatting
   flake8 .                    # Check style/linting
   codespell                   # Check spelling
   ```
7. **Fix Linting Issues**: Run automatic fixes if needed:
   ```bash
   isort .     # Fix imports
   black .     # Fix formatting
   ```
8. **Run Tests**: Ensure all tests pass including existing ones
9. **Code Quality**: Run pre-commit hooks and fix any issues
10. **Documentation**: Update relevant documentation if needed

**Important**: All linting tools (isort, black, flake8, codespell) MUST pass before code can be committed. The GitHub workflow will automatically check these requirements.

This modular architecture allows for safe development and testing of new features while maintaining the sophisticated thermostat logic that users depend on.